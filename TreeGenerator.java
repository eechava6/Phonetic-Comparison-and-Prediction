
import java.util.ArrayList;

/**
 * Created by Esteban and Sebastian on 11/6/2016.
 * All rights reserved
 */

public class TreeGenerator
{
    private boolean showTime;//If shows time
    private ArrayList<Tree> arrayRoot;//Roots
    private ArrayList<Prediction> predictions;//Predictions
    /**
     * Generates a new Object
     * with two ArrayList
     * <Tree> and <Prediction> Style
     **/
    public TreeGenerator()
    {
        this.arrayRoot = new ArrayList<>();
        this.predictions = new ArrayList<>();
        this.showTime = false;
    }
    /**
     * getter of ArrayRoot
     * @return an ArrayList<Tree> Style
     */
    public ArrayList<Tree> getArrayRoot()
    {
        return arrayRoot;
    }
    /**
     * Makes a n-ari tree with
     * @param words ArrayList
     */
    public void makeTree(ArrayList<String> words)
    {
        long startTime = System.currentTimeMillis(); //Gets current time
        for (int i = 0; i < words.size(); i++)//For each word
        {
            try
            {
                insertWord(words.get(i), this.arrayRoot);
            }
            catch(Exception e)//In case of exception
            {
                System.out.println("Word at index "+i+" is not a valid String Input");
            }
        }
        long endTime = System.currentTimeMillis();//Gets current time
        long timeMil = endTime - startTime;//Final time
        if (showTime)
        {
            System.out.println("Total time creating and buffering the tree was : " + timeMil+" miliseconds");
        }
    }
    /**
     * setter of Showtime
     * @param showTime defines if show time
     */
    public void setShowTime(boolean showTime)
    {
        this.showTime = showTime;
    }
    /**
     * Receives a String and
     * an ArrayList<Tree> Style
     * @param word decomposes word
     * into chars and generates tree
     * nodes with every char
     * @param arrayRoot
     * its a 'start'
     */
    public void insertWord(String word,ArrayList<Tree> arrayRoot)
    {
        Tree aux;
        int num = doesTreeExist(word.charAt(0),arrayRoot);//Ask if node exist - Gets it's index
        if (num == -1)//No exist
        {
            arrayRoot.add(0, new Tree(word.charAt(0)));//Buffer the node
            aux = arrayRoot.get(0);
        }
        else//Exist
        {
            aux = arrayRoot.get(num);//Gets it's location
        }
        //Ends with root

        for (int i = 1; i < word.length(); i++)//Adds a son
        {
            num = doesTreeExist(word.charAt(i), aux.getNodes());//Ask if exist - Get's its Index
            if (num != -1)//Exist
            {
                aux = aux.getNodes().get(num);
            }
            else//Otherwise
            {
                num = aux.addNodo(word.charAt(i));//Adds a new node and gets its Index
                aux = aux.getNodes().get(num);
            }
        }
        aux.setEnd();//Means word is finished - Increases End.
    }
    public int doesTreeExist(char letter, ArrayList<Tree> array)
    {
        for (int i = 0; i < array.size(); i++) {
            if (array.get(i).getLetter() == letter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Receives an ArrayList<Tree> style and
     * a String
     * @param auxArr searches for words
     * that can be created from a backUp
     * @param backUp its a word
     * that can generate other words
     */
    public void aboveWords(ArrayList<Tree> auxArr, String backUp)
    {
        try
        {
        for (int i = 0; i < auxArr.size();i++)//For each auxArr var
          {
            if (auxArr.get(i).getEnd() > 0) //If is a finished word
            {
                addPrediction(backUp+Character.toString(auxArr.get(i).getLetter()), auxArr.get(i).getEnd());//Adds full word to predictions
            }
              aboveWords(auxArr.get(i).getNodes(), backUp + Character.toString(auxArr.get(i).getLetter()));//Recursion
          }
        }catch (Exception e)//In case of exception
        {
            System.out.println("Error getting above words under "+backUp);
        }
    }

    /**
     * Receives a String and an ArrayList<Tree>
     * style
     * @param word searches wchich words can
     * be created from word
     * @param aux is where word makes
     * its research
     * @return an ArrayList<Prediction> style
     * with all words generated by word.
     */
    public ArrayList<Prediction> getPrediction(String word, ArrayList<Tree> aux)
    {
        int auxNum;
        for (int i = 0; i < word.length(); i++)//Till word length
        {
            auxNum = doesTreeExist(word.charAt(i), aux);
            if (auxNum == -1) //No exist
            {
                System.out.println("Word "+word+" has no predictions");
                return null;
            }
            if (i == word.length()-1 && aux.get(auxNum).getEnd() > 0)//if word exist
            {
                addPrediction(word,aux.get(auxNum).getEnd());
            }
            aux = aux.get(auxNum).getNodes();
        }
        aboveWords(aux,word);//Under words
        return this.predictions;
    }
    /**
     * Used only by PHONETIC
     * Receives a String and ArrayList<Tree> style
     * @param word searches for the word to increase end
     * @param aux is where word make its research
     */
    public void setIncrease(String word, ArrayList<Tree> aux)//Increase in 1 Phonetic search
    {
        int auxNum;
        for (int i = 0; i < word.length(); i++)//Till word length
        {
           auxNum = doesTreeExist(word.charAt(i),aux);//Ask if exist - Get's its Index
            if (auxNum == -1)//No exist
            {
                return;
            }
            if (i == word.length()-1 && aux.get(auxNum).getEnd() > 0)//Exist
            {
                aux.get(auxNum).setEnd(); //Increase and finish
                return;
            }
            aux = aux.get(auxNum).getNodes();
        }
    }
    /**
     * Decides how to Add Predictions
     * Receives a String and a Int
     * @param word makes a Prediction object
     * @param searched makes a Prediction object
     * If searched is bigger than other objects
     * searched, biggest searched comes firts
     */
    public void addPrediction(String word, int searched)
    {
        Prediction newPrediction = new Prediction(word,searched);
        if (predictions.isEmpty())//Empty
        {
            predictions.add(newPrediction);
        }
        else//Otherwise
        {
            for (int i = predictions.size()-1; i >= 0;)//Till predictions size
            {
                if (newPrediction.getSearched() > predictions.get(i).getSearched())//If searched is bigger
                {
                    i--;
                }
                if (newPrediction.getSearched() == predictions.get(i).getSearched() || newPrediction.getSearched() < predictions.get(i).getSearched())
                {
                    //If searched is equals or smaller
                    predictions.add(i+1,newPrediction);
                    return;
                }
                if (i == 0 && newPrediction.getSearched() > predictions.get(i).getSearched())//If index is 0 and searched is bigger
                {
                    predictions.add(i,newPrediction);
                    return;
                }
            }
        }
    }
}



